#'@title Function make_tiers
#'@param setLists a setList of protein groups generated by \code{\link{make_proteinGroups_setList}}()
#'@description Generate a tier list from a set of lists of protein groups identified by MaxQuant for cross-list comparisons. This function calls Max_Venn() and calculates sums of redundant Venn table generated by Max_Venn. Individual proteins in each protein group are compared to others; each protein group is treated as a vector of individual string elements for comparisons. Also see \code{\link{Max_Venn}}(IndividualAnalysis = TRUE)
#'@export
make_tiers <- function(setLists) {
 #Call Max_Venn on setList
 maxVennOutput <- Max_Venn(setLists, IndividualAnalysis = TRUE)
 #Remove the null debugging field
 IntersectionSets <- maxVennOutput@IntersectionSets[-1]
 #Get len1 as the number of venn fields
 len1 <- length(IntersectionSets)
 n_levels <- sapply(1:len1,function(x)NULL)
 #Get len2 as the number of levels/tiers
 for (n_field in 1:len1)
 {
   field_name <- names(IntersectionSets)[n_field]
   n_levels[[n_field]] <- sum(as.integer(unlist(strsplit(field_name,""))))
 }
 len2 <- max(unlist(n_levels))
 levels <- sapply(1:len2,function(x)NULL)
 for (n_field in 1:len1)
 {
   field_name <- names(IntersectionSets)[n_field]
   field_level <- sum(as.integer(unlist(strsplit(field_name,""))))
   levels[[field_level]] <- union(levels[[field_level]], maxVennOutput@IntersectionSets[[field_name]])
 }
 #The smaller the tier number is the higher the level, best tier has highest level
 n_tiers <- length(levels)
 tiers <- sapply(1:n_tiers,function(x)NULL)
 j <- n_tiers
 for (i in 1 : n_tiers) {
   tier_name <- paste("Tier ", as.roman(j), sep = "")
   names(tiers)[j] <- tier_name
   tiers[[j]] <- levels[[i]]
   j = j - 1
 }
 return(tiers)
}

#'@title Subroutine plot_target
#'@description  The plot_target Subroutine draws a target plot showing protein group ID numbers in Tiers.
#'@param tiers a list generated by \code{\link{make_tiers}}() function.
#'@param title a string shown as the title. Default value is NULL.
#'@export
plot_target <- function(tiers, edges = 2000, density = 2000, angle = 45, border = FALSE, lty = NULL, title = NULL) {
   x = as.integer(lengths(tiers))
   labels = names(tiers)
   if (is.null(labels))
      labels <- paste0("Set ", as.character(seq_along(x)))
   else labels <- as.graphicsAnnot(labels)
   x <- c(0, cumsum(x)/sum(x))
   dx <- diff(x)
   nx <- length(dx)
   col = rev(brewer.pal(nx,'YlOrRd'))
   plot.new()
   pin <- par("pin")
   xlim <- ylim <- c(-1, 1)
   if (pin[1L] > pin[2L])
      xlim <- (pin[1L]/pin[2L]) * xlim
   else ylim <- (pin[2L]/pin[1L]) * ylim
   plot.window(xlim, ylim, "", asp = 1)
   if (is.null(col))
      col <- if (is.null(density))
         palette()
   else par("fg")
   col <- rep(col, length.out = nx)
   border <- rep(border, length.out = nx)
   lty <- rep(lty, length.out = nx)
   angle <- rep(angle, length.out = nx)
   density <- rep(density, length.out = nx)
   twopi <- -2 * pi
   t2xy <- function(t, radius) {
      t2p <- twopi * t + 90 * pi/180
      list(x = radius * cos(t2p),
           y = radius * sin(t2p))
   }
   radius <- sqrt(x[-1])
   for (i in nx:1) {
      n <- max(2, floor(edges * dx[i]))
      Pin <- t2xy(seq.int(0, 1, length.out = n*nx),
                  radius[i])
      polygon(Pin$x, Pin$y, density = density[i],
              angle = angle[i], border = border[i],
              col = col[i], lty = lty[i])
   }
   for (i in nx:1) {
      Pout <- t2xy(0.092*i, 0.56*(x[i] + sqrt(x[i])))
      lab <- paste0(as.character(labels[i]), "\n", "(", length(tiers[[i]]), ")")
      if (!is.na(lab) && nzchar(lab)) {
         text(1.1 * Pout$x, 1.3 * Pout$y, lab,
              xpd = TRUE, adj = ifelse(Pout$x < 0, 1, 0))
      }
   }
   title(main = title)
}



